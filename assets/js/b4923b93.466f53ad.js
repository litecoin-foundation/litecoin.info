"use strict";(self.webpackChunklitecoin_info=self.webpackChunklitecoin_info||[]).push([[431],{5806:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>b,frontMatter:()=>d,metadata:()=>a,toc:()=>r});var t=c(4848),o=c(8453);const d={sidebar_position:1},s="Proof of Work",a={id:"key-concepts/proof-of-work",title:"Proof of Work",description:"Litecoin uses Scrypt Proof of Work (PoW), with parameters N=1024, r=1 and p=1. The salt is the same 80 bytes as the input.",source:"@site/docs/key-concepts/proof-of-work.md",sourceDirName:"key-concepts",slug:"/key-concepts/proof-of-work",permalink:"/docs/key-concepts/proof-of-work",draft:!1,unlisted:!1,editUrl:"https://github.com/litecoin-foundation/litecoin.info/tree/main/packages/create-docusaurus/templates/shared/docs/key-concepts/proof-of-work.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Magic Numbers",permalink:"/docs/key-concepts/magic-numbers"},next:{title:"Testnet",permalink:"/docs/key-concepts/testnet"}},i={},r=[{value:"Scrypt during mining",id:"scrypt-during-mining",level:3},{value:"Example dbdump of block #29255",id:"example-dbdump-of-block-29255",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"proof-of-work",children:"Proof of Work"}),"\n",(0,t.jsxs)(n.p,{children:["Litecoin uses Scrypt Proof of Work (PoW), with parameters ",(0,t.jsx)(n.code,{children:"N=1024"}),", ",(0,t.jsx)(n.code,{children:"r=1"})," and ",(0,t.jsx)(n.code,{children:"p=1"}),". The ",(0,t.jsx)(n.code,{children:"salt"})," is the same 80 bytes as the input.\nThe output is 256bits (32 bytes). The scrypt implementation in C++ used by Litecoin Core is adapted from Colin Perseval's Tarsnap,\nand can be found in ",(0,t.jsx)(n.a,{href:"https://github.com/litecoin-project/litecoin/blob/master/src/crypto/scrypt.cpp",children:(0,t.jsx)(n.code,{children:"src/crypto/scrypt.cpp"})}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"scrypt-during-mining",children:"Scrypt during mining"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ litecoind getwork\n{\n    "midstate" : "40fd268321efcf60e625707d4e31f9deadd13157e228985de8a10a057b98ed4d",\n    "data" : "0000000105e9a54b7f65b46864bc90f55d67cccd8b6404a02f5e064a6df69282adf6e2e5f7f953b0632b25b099858b717bb7b24084148cfa841a89f106bc6b655b18d2ed4ebb191a1d018ea700000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000",\n    "hash1" : "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000",\n    "target" : "0000000000000000000000000000000000000000000000000000a78e01000000"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The data field is stored in big-endian format. We need to cover that to little-endian for each of the fields in the data because we can pass it to the hashing function."}),"\n",(0,t.jsx)(n.p,{children:"Data is broken down to:"}),"\n",(0,t.jsxs)(n.p,{children:["Version - ",(0,t.jsx)(n.code,{children:"00000001"})," (4 bytes)\nPrevious hash - ",(0,t.jsx)(n.code,{children:"05e9a54b7f65b46864bc90f55d67cccd8b6404a02f5e064a6df69282adf6e2e5"})," (32 bytes)\nMerkle root - ",(0,t.jsx)(n.code,{children:"f7f953b0632b25b099858b717bb7b24084148cfa841a89f106bc6b655b18d2ed"})," (32 bytes)\nTimestamp - ",(0,t.jsx)(n.code,{children:"4ebb191a"})," (4 bytes)\nBits (target in compact form) - ",(0,t.jsx)(n.code,{children:"1d018ea7"})," (4 bytes)\nNonce - ",(0,t.jsx)(n.code,{children:"00000000"})," (4 bytes)"]}),"\n",(0,t.jsx)(n.p,{children:"You need covert these from big-endian to little-endian. This is done 2 characters at a time because each byte is represented by 2 hex chars. (each hex char is 4 bits)"}),"\n",(0,t.jsxs)(n.p,{children:["Version becomes ",(0,t.jsx)(n.code,{children:"01000000"}),"\nPrevious hash becomes ",(0,t.jsx)(n.code,{children:"e5e2f6.....a5e905"}),"\nMerkle root becomes ",(0,t.jsx)(n.code,{children:"edd218...53f9f7"}),"\nTimestamp becomes ",(0,t.jsx)(n.code,{children:"1a19bb4e"}),"\nBits becomes ",(0,t.jsx)(n.code,{children:"a78e011d"}),"\nAnd Nonce is a 32-bit integer you choose that will make the scrypt hash be less than the target."]}),"\n",(0,t.jsxs)(n.p,{children:["Remember that you will need to convert the 32-bit nonce to hex and little-endian also. So if you are trying the nonce ",(0,t.jsx)(n.code,{children:"2504433986"}),". The hex version is ",(0,t.jsx)(n.code,{children:"9546a142"})," in big-endian and ",(0,t.jsx)(n.code,{children:"42a14695"})," in little-endian."]}),"\n",(0,t.jsx)(n.p,{children:"You then concatenate these little-endian hex strings together to get the header string (80 bytes) you input into scrypt"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"01000000 e5e2f6.....a5e905 edd218...53f9f7 1a19bb4e a78e011d 42a14695"})}),"\n",(0,t.jsx)(n.h3,{id:"example-dbdump-of-block-29255",children:"Example dbdump of block #29255"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ./dbdump.py --datadir=/home/mining/.litecoin/ --block 29255\nBlock height: 29255\nBLOCK adf6e2e56df692822f5e064a8b6404a05d67cccd64bc90f57f65b46805e9a54b\nNext block: 0000000000000000000000000000000000000000000000000000000000000000\nTime: Wed Nov  9 16:15:52 2011 Nonce: 3562614017\nnBits: 0x0x1d018ea7\nhashMerkleRoot: 0x066b2a758399d5f19b5c6073d09b500d925982adc4b3edd352efe14667a8ca9f\nPrevious block: 279f6330ccbbb9103b9e3a5350765052081ddbae898f1ef6b8c64f3bcef715f6\n1 transactions:\n1 tx in, 1 out\nTxIn: COIN GENERATED coinbase:04b217bb4e022309\nTxOut: value: 50.000000 pubkey: 1HXG8MWvUFNU3pLpQUJueSC4kHcrNepuwC Script: 65:0448...b8cd CHECKSIG\n\nRaw block header: 01000000f615f7ce3b4fc6b8f61e8f89aedb1d0852507650533a9e3b10b9bbcc30639f279fcaa86746e1ef52d3edb3c4ad8259920d509bd073605c9bf1d59983752a6b06b817bb4ea78e011d012d59d4\n"})}),"\n",(0,t.jsx)(n.p,{children:"This python script be used to get a block hash, which matches the expect hash of block #29255"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import hashlib\nimport ltc_scrypt\n\nheader_hex = \"01000000f615f7ce3b4fc6b8f61e8f89aedb1d0852507650533a9e3b10b9bbcc30639f279fcaa86746e1ef52d3edb3c4ad8259920d509bd073605c9bf1d59983752a6b06b817bb4ea78e011d012d59d4\"\nheader_bin = header_hex.decode('hex')\n\n# sha256d hash\nhash = hashlib.sha256(hashlib.sha256(header_bin).digest()).digest()\nhash.encode('hex_codec')\nhash[::-1].encode('hex_codec')    # convert from big-endian to little-endian\n# hash = adf6e2e56df692822f5e064a8b6404a05d67cccd64bc90f57f65b46805e9a54b\n\n# scrypt hash\nscrypt = ltc_scrypt.getPoWHash(header_bin)\nscrypt.encode('hex_codec')\nscrypt[::-1].encode('hex_codec')    # convert from big-endian to little-endian\n# scrypt hash = 0000000110c8357966576df46f3b802ca897deb7ad18b12f1c24ecff6386ebd9\n"})})]})}function b(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,c)=>{c.d(n,{R:()=>s,x:()=>a});var t=c(6540);const o={},d=t.createContext(o);function s(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);